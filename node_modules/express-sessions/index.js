var express = require('express');
var mongoose = require('mongoose');
var Schema = mongoose.Schema;
var model;

var Sessions = new Schema({
    sid: { type: String, required: true, unique: true },
    data: { type: {} },
    lastAccess: { type: Date, index: true },
    expires: { type: Date, index: true }
});

var Store = express.session.Store;

var MongoStore = function (options, cb) {
    var options = {
        mongoose: options.mongoose || null,
        collection: options.collection || 'sessions',
        cleanup_interval: options.cleanup_interval || 86400
    };

    if (options.mongoose) {
        mongoose = options.mongoose;
    }

    Store.call(this, options);

    model = mongoose.model('sessions', Sessions);

    if (cb) cb.call(null);

    if (options.cleanup_interval) {
        setInterval(function () {
            model.remove({expires: {
                $lt: new Date()
            }}, function (err) {
                if (err) {
                    console.log('[express-sessions]', err);
                }
            });

        }, parseInt(options.cleanup_interval) * 1000);
    }
}

MongoStore.prototype = new Store();

MongoStore.prototype.get = function (sid, cb) {
    model.findOne({sid: sid}, function (err, doc) {
        try {
            if (err) return cb(err, null);

            if (!doc) return cb();

            cb(null, JSON.parse(doc.data));
        }
        catch (err) {
            cb(err);
        }
    });
}

MongoStore.prototype.set = function (sid, data, cb) {
    try {
        var lastAccess = new Date();
        var expires = lastAccess.setDate(lastAccess.getDate() + 1);

        if (typeof data.cookie != 'undefined') {
            expires = data.cookie._expires;
        }

        if (typeof data.lastAccess != 'undefined') {
            lastAccess = new Date(data.lastAccess);
        }

//        var m = new model(
//                {
//                    data: data,
//                    lastAccess: lastAccess,
//                    expires: expires
//                }
//        );
//        m.save(function(){
//            console.log(arguments)
//        });

        model.findOneAndUpdate({sid: sid}, {
            data: JSON.stringify(data),
            lastAccess: lastAccess,
            expires: expires
        }, { upsert: true }, cb);
    }
    catch (err) {
        console.log(err)
        cb && cb(err);
    }
}

MongoStore.prototype.destroy = function (sid, cb) {
    model.remove({ sid: sid }, cb);
}

MongoStore.prototype.all = function (cb) {
    model.find(function (err, doc) {
        if (err) {
            return cb && cb(err);
        }

        cb && cb(null, doc);
    });
}

MongoStore.prototype.length = function (cb) {
    model.count(function (err, count) {
        if (err) {
            return cb && cb(err);
        }

        cb && cb(null, count);
    });
}

MongoStore.prototype.clear = function (cb) {
    model.drop(function () {
        if (err) {
            return cb && cb(err);
        }

        cb && cb();
    });
}

module.exports = MongoStore;