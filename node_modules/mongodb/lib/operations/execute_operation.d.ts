import type { Document } from '../bson';
import type { MongoClient } from '../mongo_client';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { Callback } from '../utils';
import { AbstractOperation } from './operation';
type ResultTypeFromOperation<TOperation> = TOperation extends AbstractOperation<infer K> ? K : never;
/** @internal */
export interface ExecutionResult {
    /** The server selected for the operation */
    server: Server;
    /** The session used for this operation, may be implicitly created */
    session?: ClientSession;
    /** The raw server response for the operation */
    response: Document;
}
/**
 * Executes the given operation with provided arguments.
 * @internal
 *
 * @remarks
 * This method reduces large amounts of duplication in the entire codebase by providing
 * a single point for determining whether callbacks or promises should be used. Additionally
 * it allows for a single point of entry to provide features such as implicit sessions, which
 * are required by the Driver Sessions specification in the event that a ClientSession is
 * not provided
 *
 * @param topology - The topology to execute this operation on
 * @param operation - The operation to execute
 * @param callback - The command result callback
 */
export declare function executeOperation<T extends AbstractOperation<TResult>, TResult = ResultTypeFromOperation<T>>(client: MongoClient, operation: T): Promise<TResult>;
export declare function executeOperation<T extends AbstractOperation<TResult>, TResult = ResultTypeFromOperation<T>>(client: MongoClient, operation: T, callback: Callback<TResult>): void;
export declare function executeOperation<T extends AbstractOperation<TResult>, TResult = ResultTypeFromOperation<T>>(client: MongoClient, operation: T, callback?: Callback<TResult>): Promise<TResult> | void;
export {};
//# sourceMappingURL=execute_operation.d.ts.map