import { BSONSerializeOptions, Document } from '../bson';
import { ReadPreference, ReadPreferenceLike } from '../read_preference';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import type { Callback, MongoDBNamespace } from '../utils';
export declare const Aspect: {
    readonly READ_OPERATION: symbol;
    readonly WRITE_OPERATION: symbol;
    readonly RETRYABLE: symbol;
    readonly EXPLAINABLE: symbol;
    readonly SKIP_COLLATION: symbol;
    readonly CURSOR_CREATING: symbol;
    readonly MUST_SELECT_SAME_SERVER: symbol;
};
/** @public */
export type Hint = string | Document;
export interface OperationConstructor extends Function {
    aspects?: Set<symbol>;
}
/** @public */
export interface OperationOptions extends BSONSerializeOptions {
    /** Specify ClientSession for this command */
    session?: ClientSession;
    willRetryWrite?: boolean;
    /** The preferred read preference (ReadPreference.primary, ReadPreference.primary_preferred, ReadPreference.secondary, ReadPreference.secondary_preferred, ReadPreference.nearest). */
    readPreference?: ReadPreferenceLike;
    /** @internal Hints to `executeOperation` that this operation should not unpin on an ended transaction */
    bypassPinningCheck?: boolean;
    omitReadPreference?: boolean;
}
/** @internal */
declare const kSession: unique symbol;
/**
 * This class acts as a parent class for any operation and is responsible for setting this.options,
 * as well as setting and getting a session.
 * Additionally, this class implements `hasAspect`, which determines whether an operation has
 * a specific aspect.
 * @internal
 */
export declare abstract class AbstractOperation<TResult = any> {
    ns: MongoDBNamespace;
    cmd: Document;
    readPreference: ReadPreference;
    server: Server;
    bypassPinningCheck: boolean;
    trySecondaryWrite: boolean;
    bsonOptions?: BSONSerializeOptions;
    options: OperationOptions;
    [kSession]: ClientSession | undefined;
    executeAsync: (server: Server, session: ClientSession | undefined) => Promise<TResult>;
    constructor(options?: OperationOptions);
    abstract execute(server: Server, session: ClientSession | undefined, callback: Callback<TResult>): void;
    hasAspect(aspect: symbol): boolean;
    get session(): ClientSession | undefined;
    clearSession(): void;
    get canRetryRead(): boolean;
    get canRetryWrite(): boolean;
}
export declare function defineAspects(operation: OperationConstructor, aspects: symbol | symbol[] | Set<symbol>): Set<symbol>;
export {};
//# sourceMappingURL=operation.d.ts.map