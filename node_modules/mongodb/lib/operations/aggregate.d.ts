import type { Document } from '../bson';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { Callback, MongoDBNamespace } from '../utils';
import { CollationOptions, CommandOperation, CommandOperationOptions } from './command';
import { Hint } from './operation';
/** @internal */
export declare const DB_AGGREGATE_COLLECTION: 1;
/** @public */
export interface AggregateOptions extends CommandOperationOptions {
    /** allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 \>). */
    allowDiskUse?: boolean;
    /** The number of documents to return per batch. See [aggregation documentation](https://docs.mongodb.com/manual/reference/command/aggregate). */
    batchSize?: number;
    /** Allow driver to bypass schema validation in MongoDB 3.2 or higher. */
    bypassDocumentValidation?: boolean;
    /** Return the query as cursor, on 2.6 \> it returns as a real cursor on pre 2.6 it returns as an emulated cursor. */
    cursor?: Document;
    /** specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point. */
    maxTimeMS?: number;
    /** The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. */
    maxAwaitTimeMS?: number;
    /** Specify collation. */
    collation?: CollationOptions;
    /** Add an index selection hint to an aggregation command */
    hint?: Hint;
    /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */
    let?: Document;
    out?: string;
}
/** @internal */
export declare class AggregateOperation<T = Document> extends CommandOperation<T> {
    options: AggregateOptions;
    target: string | typeof DB_AGGREGATE_COLLECTION;
    pipeline: Document[];
    hasWriteStage: boolean;
    constructor(ns: MongoDBNamespace, pipeline: Document[], options?: AggregateOptions);
    get canRetryRead(): boolean;
    addToPipeline(stage: Document): void;
    execute(server: Server, session: ClientSession | undefined, callback: Callback<T>): void;
}
//# sourceMappingURL=aggregate.d.ts.map