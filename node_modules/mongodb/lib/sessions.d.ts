import { Binary, Document, Timestamp } from './bson';
import type { CommandOptions, Connection } from './cmap/connection';
import type { AbstractCursor } from './cursor/abstract_cursor';
import { AnyError, MongoDriverError } from './error';
import type { MongoClient, MongoOptions } from './mongo_client';
import { TypedEventEmitter } from './mongo_types';
import { ClusterTime } from './sdam/common';
import { Transaction, TransactionOptions } from './transactions';
import { List } from './utils';
/** @public */
export interface ClientSessionOptions {
    /** Whether causal consistency should be enabled on this session */
    causalConsistency?: boolean;
    /** Whether all read operations should be read from the same snapshot for this session (NOTE: not compatible with `causalConsistency=true`) */
    snapshot?: boolean;
    /** The default TransactionOptions to use for transactions started on this session. */
    defaultTransactionOptions?: TransactionOptions;
    /** @internal */
    owner?: symbol | AbstractCursor;
    /** @internal */
    explicit?: boolean;
    /** @internal */
    initialClusterTime?: ClusterTime;
}
/** @public */
export type WithTransactionCallback<T = void> = (session: ClientSession) => Promise<T>;
/** @public */
export type ClientSessionEvents = {
    ended(session: ClientSession): void;
};
/** @internal */
declare const kServerSession: unique symbol;
/** @internal */
declare const kSnapshotTime: unique symbol;
/** @internal */
declare const kSnapshotEnabled: unique symbol;
/** @internal */
declare const kPinnedConnection: unique symbol;
/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */
declare const kTxnNumberIncrement: unique symbol;
/** @public */
export interface EndSessionOptions {
    /**
     * An optional error which caused the call to end this session
     * @internal
     */
    error?: AnyError;
    force?: boolean;
    forceClear?: boolean;
}
/**
 * A class representing a client session on the server
 *
 * NOTE: not meant to be instantiated directly.
 * @public
 */
export declare class ClientSession extends TypedEventEmitter<ClientSessionEvents> {
    /** @internal */
    client: MongoClient;
    /** @internal */
    sessionPool: ServerSessionPool;
    hasEnded: boolean;
    clientOptions?: MongoOptions;
    supports: {
        causalConsistency: boolean;
    };
    clusterTime?: ClusterTime;
    operationTime?: Timestamp;
    explicit: boolean;
    /** @internal */
    owner?: symbol | AbstractCursor;
    defaultTransactionOptions: TransactionOptions;
    transaction: Transaction;
    /** @internal */
    [kServerSession]: ServerSession | null;
    /** @internal */
    [kSnapshotTime]?: Timestamp;
    /** @internal */
    [kSnapshotEnabled]: boolean;
    /** @internal */
    [kPinnedConnection]?: Connection;
    /** @internal */
    [kTxnNumberIncrement]: number;
    /**
     * Create a client session.
     * @internal
     * @param client - The current client
     * @param sessionPool - The server session pool (Internal Class)
     * @param options - Optional settings
     * @param clientOptions - Optional settings provided when creating a MongoClient
     */
    constructor(client: MongoClient, sessionPool: ServerSessionPool, options: ClientSessionOptions, clientOptions?: MongoOptions);
    /** The server id associated with this session */
    get id(): ServerSessionId | undefined;
    get serverSession(): ServerSession;
    /** Whether or not this session is configured for snapshot reads */
    get snapshotEnabled(): boolean;
    get loadBalanced(): boolean;
    /** @internal */
    get pinnedConnection(): Connection | undefined;
    /** @internal */
    pin(conn: Connection): void;
    /** @internal */
    unpin(options?: {
        force?: boolean;
        forceClear?: boolean;
        error?: AnyError;
    }): void;
    get isPinned(): boolean;
    /**
     * Ends this session on the server
     *
     * @param options - Optional settings. Currently reserved for future use
     */
    endSession(options?: EndSessionOptions): Promise<void>;
    /**
     * Advances the operationTime for a ClientSession.
     *
     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to
     */
    advanceOperationTime(operationTime: Timestamp): void;
    /**
     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession
     *
     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature
     */
    advanceClusterTime(clusterTime: ClusterTime): void;
    /**
     * Used to determine if this session equals another
     *
     * @param session - The session to compare to
     */
    equals(session: ClientSession): boolean;
    /**
     * Increment the transaction number on the internal ServerSession
     *
     * @privateRemarks
     * This helper increments a value stored on the client session that will be
     * added to the serverSession's txnNumber upon applying it to a command.
     * This is because the serverSession is lazily acquired after a connection is obtained
     */
    incrementTransactionNumber(): void;
    /** @returns whether this session is currently in a transaction or not */
    inTransaction(): boolean;
    /**
     * Starts a new transaction with the given options.
     *
     * @param options - Options for the transaction
     */
    startTransaction(options?: TransactionOptions): void;
    /**
     * Commits the currently active transaction in this session.
     */
    commitTransaction(): Promise<Document>;
    /**
     * Aborts the currently active transaction in this session.
     */
    abortTransaction(): Promise<Document>;
    /**
     * This is here to ensure that ClientSession is never serialized to BSON.
     */
    toBSON(): never;
    /**
     * Runs a provided callback within a transaction, retrying either the commitTransaction operation
     * or entire transaction as needed (and when the error permits) to better ensure that
     * the transaction can complete successfully.
     *
     * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.
     * Any callbacks that do not return a Promise will result in undefined behavior.
     *
     * @remarks
     * This function:
     * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)
     * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`
     * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback
     *
     * Checkout a descriptive example here:
     * @see https://www.mongodb.com/developer/quickstart/node-transactions/
     *
     * @param fn - callback to run within a transaction
     * @param options - optional settings for the transaction
     * @returns A raw command response or undefined
     */
    withTransaction<T = void>(fn: WithTransactionCallback<T>, options?: TransactionOptions): Promise<Document | undefined>;
}
export declare function maybeClearPinnedConnection(session: ClientSession, options?: EndSessionOptions): void;
/** @public */
export type ServerSessionId = {
    id: Binary;
};
/**
 * Reflects the existence of a session on the server. Can be reused by the session pool.
 * WARNING: not meant to be instantiated directly. For internal use only.
 * @public
 */
export declare class ServerSession {
    id: ServerSessionId;
    lastUse: number;
    txnNumber: number;
    isDirty: boolean;
    /** @internal */
    constructor();
    /**
     * Determines if the server session has timed out.
     *
     * @param sessionTimeoutMinutes - The server's "logicalSessionTimeoutMinutes"
     */
    hasTimedOut(sessionTimeoutMinutes: number): boolean;
    /**
     * @internal
     * Cloning meant to keep a readable reference to the server session data
     * after ClientSession has ended
     */
    static clone(serverSession: ServerSession): Readonly<ServerSession>;
}
/**
 * Maintains a pool of Server Sessions.
 * For internal use only
 * @internal
 */
export declare class ServerSessionPool {
    client: MongoClient;
    sessions: List<ServerSession>;
    constructor(client: MongoClient);
    /**
     * Acquire a Server Session from the pool.
     * Iterates through each session in the pool, removing any stale sessions
     * along the way. The first non-stale session found is removed from the
     * pool and returned. If no non-stale session is found, a new ServerSession is created.
     */
    acquire(): ServerSession;
    /**
     * Release a session to the session pool
     * Adds the session back to the session pool if the session has not timed out yet.
     * This method also removes any stale sessions from the pool.
     *
     * @param session - The session to release to the pool
     */
    release(session: ServerSession): void;
}
/**
 * Optionally decorate a command with sessions specific keys
 *
 * @param session - the session tracking transaction state
 * @param command - the command to decorate
 * @param options - Optional settings passed to calling operation
 *
 * @internal
 */
export declare function applySession(session: ClientSession, command: Document, options: CommandOptions): MongoDriverError | undefined;
export declare function updateSessionFromResponse(session: ClientSession, document: Document): void;
export {};
//# sourceMappingURL=sessions.d.ts.map