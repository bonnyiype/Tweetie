import type { Document, Long, Timestamp } from '../bson';
import { type ChangeStreamDocument, type ChangeStreamEvents, type OperationTime, type ResumeToken } from '../change_stream';
import type { MongoClient } from '../mongo_client';
import type { CollationOptions } from '../operations/command';
import { type ExecutionResult } from '../operations/execute_operation';
import type { ClientSession } from '../sessions';
import { type Callback, type MongoDBNamespace } from '../utils';
import { type AbstractCursorOptions, AbstractCursor } from './abstract_cursor';
/** @internal */
export interface ChangeStreamCursorOptions extends AbstractCursorOptions {
    startAtOperationTime?: OperationTime;
    resumeAfter?: ResumeToken;
    startAfter?: ResumeToken;
    maxAwaitTimeMS?: number;
    collation?: CollationOptions;
    fullDocument?: string;
}
/** @internal */
export type ChangeStreamAggregateRawResult<TChange> = {
    $clusterTime: {
        clusterTime: Timestamp;
    };
    cursor: {
        postBatchResumeToken: ResumeToken;
        ns: string;
        id: number | Long;
    } & ({
        firstBatch: TChange[];
    } | {
        nextBatch: TChange[];
    });
    ok: 1;
    operationTime: Timestamp;
};
/** @internal */
export declare class ChangeStreamCursor<TSchema extends Document = Document, TChange extends Document = ChangeStreamDocument<TSchema>> extends AbstractCursor<TChange, ChangeStreamEvents> {
    _resumeToken: ResumeToken;
    startAtOperationTime?: OperationTime;
    hasReceived?: boolean;
    resumeAfter: ResumeToken;
    startAfter: ResumeToken;
    options: ChangeStreamCursorOptions;
    postBatchResumeToken?: ResumeToken;
    pipeline: Document[];
    /**
     * @internal
     *
     * used to determine change stream resumability
     */
    maxWireVersion: number | undefined;
    constructor(client: MongoClient, namespace: MongoDBNamespace, pipeline?: Document[], options?: ChangeStreamCursorOptions);
    set resumeToken(token: ResumeToken);
    get resumeToken(): ResumeToken;
    get resumeOptions(): ChangeStreamCursorOptions;
    cacheResumeToken(resumeToken: ResumeToken): void;
    _processBatch(response: ChangeStreamAggregateRawResult<TChange>): void;
    clone(): AbstractCursor<TChange>;
    _initialize(session: ClientSession, callback: Callback<ExecutionResult>): void;
    _getMore(batchSize: number, callback: Callback): void;
}
//# sourceMappingURL=change_stream_cursor.d.ts.map