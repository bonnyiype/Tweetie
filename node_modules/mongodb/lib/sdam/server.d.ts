import type { Document } from '../bson';
import { CommandOptions, Connection, DestroyOptions } from '../cmap/connection';
import { ConnectionPool, ConnectionPoolEvents, ConnectionPoolOptions } from '../cmap/connection_pool';
import type { AutoEncrypter } from '../deps';
import { AnyError } from '../error';
import type { ServerApi } from '../mongo_client';
import { TypedEventEmitter } from '../mongo_types';
import { Callback, EventEmitterWithState, MongoDBNamespace } from '../utils';
import { ClusterTime } from './common';
import type { ServerHeartbeatFailedEvent, ServerHeartbeatStartedEvent, ServerHeartbeatSucceededEvent } from './events';
import { Monitor, MonitorOptions } from './monitor';
import { ServerDescription } from './server_description';
import type { Topology } from './topology';
/** @internal */
declare const kMonitor: unique symbol;
/** @internal */
export type ServerOptions = Omit<ConnectionPoolOptions, 'id' | 'generation' | 'hostAddress'> & MonitorOptions;
/** @internal */
export interface ServerPrivate {
    /** The server description for this server */
    description: ServerDescription;
    /** A copy of the options used to construct this instance */
    options: ServerOptions;
    /** The current state of the Server */
    state: string;
    /** The topology this server is a part of */
    topology: Topology;
    /** A connection pool for this server */
    pool: ConnectionPool;
    /** MongoDB server API version */
    serverApi?: ServerApi;
    /** A count of the operations currently running against the server. */
    operationCount: number;
}
/** @public */
export type ServerEvents = {
    serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;
    serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;
    serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;
    /** Top level MongoClient doesn't emit this so it is marked: @internal */
    connect(server: Server): void;
    descriptionReceived(description: ServerDescription): void;
    closed(): void;
    ended(): void;
} & ConnectionPoolEvents & EventEmitterWithState;
/** @internal */
export declare class Server extends TypedEventEmitter<ServerEvents> {
    /** @internal */
    s: ServerPrivate;
    serverApi?: ServerApi;
    hello?: Document;
    [kMonitor]: Monitor | null;
    /** @event */
    static readonly SERVER_HEARTBEAT_STARTED: "serverHeartbeatStarted";
    /** @event */
    static readonly SERVER_HEARTBEAT_SUCCEEDED: "serverHeartbeatSucceeded";
    /** @event */
    static readonly SERVER_HEARTBEAT_FAILED: "serverHeartbeatFailed";
    /** @event */
    static readonly CONNECT: "connect";
    /** @event */
    static readonly DESCRIPTION_RECEIVED = "descriptionReceived";
    /** @event */
    static readonly CLOSED: "closed";
    /** @event */
    static readonly ENDED: "ended";
    /**
     * Create a server
     */
    constructor(topology: Topology, description: ServerDescription, options: ServerOptions);
    get clusterTime(): ClusterTime | undefined;
    set clusterTime(clusterTime: ClusterTime | undefined);
    get description(): ServerDescription;
    get name(): string;
    get autoEncrypter(): AutoEncrypter | undefined;
    get loadBalanced(): boolean;
    /**
     * Initiate server connect
     */
    connect(): void;
    /** Destroy the server connection */
    destroy(options?: DestroyOptions, callback?: Callback): void;
    /**
     * Immediately schedule monitoring of this server. If there already an attempt being made
     * this will be a no-op.
     */
    requestCheck(): void;
    /**
     * Execute a command
     * @internal
     */
    command(ns: MongoDBNamespace, cmd: Document, options: CommandOptions, callback: Callback<Document>): void;
    /**
     * Handle SDAM error
     * @internal
     */
    handleError(error: AnyError, connection?: Connection): void;
}
export {};
//# sourceMappingURL=server.d.ts.map