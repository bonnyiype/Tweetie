/// <reference types="node" />
import { Connection, ConnectionOptions } from '../cmap/connection';
import { MongoError } from '../error';
import { CancellationToken, TypedEventEmitter } from '../mongo_types';
import type { Callback } from '../utils';
import { EventEmitterWithState } from '../utils';
import { ServerHeartbeatFailedEvent, ServerHeartbeatStartedEvent, ServerHeartbeatSucceededEvent } from './events';
import { Server } from './server';
/** @internal */
declare const kServer: unique symbol;
/** @internal */
declare const kMonitorId: unique symbol;
/** @internal */
declare const kConnection: unique symbol;
/** @internal */
declare const kCancellationToken: unique symbol;
/** @internal */
declare const kRTTPinger: unique symbol;
/** @internal */
declare const kRoundTripTime: unique symbol;
/** @internal */
export interface MonitorPrivate {
    state: string;
}
/** @public */
export interface MonitorOptions extends Omit<ConnectionOptions, 'id' | 'generation' | 'hostAddress'> {
    connectTimeoutMS: number;
    heartbeatFrequencyMS: number;
    minHeartbeatFrequencyMS: number;
}
/** @public */
export type MonitorEvents = {
    serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;
    serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;
    serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;
    resetServer(error?: MongoError): void;
    resetConnectionPool(): void;
    close(): void;
} & EventEmitterWithState;
/** @internal */
export declare class Monitor extends TypedEventEmitter<MonitorEvents> {
    /** @internal */
    s: MonitorPrivate;
    address: string;
    options: Readonly<Pick<MonitorOptions, 'connectTimeoutMS' | 'heartbeatFrequencyMS' | 'minHeartbeatFrequencyMS'>>;
    connectOptions: ConnectionOptions;
    [kServer]: Server;
    [kConnection]?: Connection;
    [kCancellationToken]: CancellationToken;
    /** @internal */
    [kMonitorId]?: MonitorInterval;
    [kRTTPinger]?: RTTPinger;
    get connection(): Connection | undefined;
    constructor(server: Server, options: MonitorOptions);
    connect(): void;
    requestCheck(): void;
    reset(): void;
    close(): void;
}
/** @internal */
export interface RTTPingerOptions extends ConnectionOptions {
    heartbeatFrequencyMS: number;
}
/** @internal */
export declare class RTTPinger {
    /** @internal */
    [kConnection]?: Connection;
    /** @internal */
    [kCancellationToken]: CancellationToken;
    /** @internal */
    [kRoundTripTime]: number;
    /** @internal */
    [kMonitorId]: NodeJS.Timeout;
    closed: boolean;
    constructor(cancellationToken: CancellationToken, options: RTTPingerOptions);
    get roundTripTime(): number;
    close(): void;
}
/**
 * @internal
 */
export interface MonitorIntervalOptions {
    /** The interval to execute a method on */
    heartbeatFrequencyMS: number;
    /** A minimum interval that must elapse before the method is called */
    minHeartbeatFrequencyMS: number;
    /** Whether the method should be called immediately when the interval is started  */
    immediate: boolean;
}
/**
 * @internal
 */
export declare class MonitorInterval {
    fn: (callback: Callback) => void;
    timerId: NodeJS.Timeout | undefined;
    lastExecutionEnded: number;
    isExpeditedCallToFnScheduled: boolean;
    stopped: boolean;
    isExecutionInProgress: boolean;
    hasExecutedOnce: boolean;
    heartbeatFrequencyMS: number;
    minHeartbeatFrequencyMS: number;
    constructor(fn: (callback: Callback) => void, options?: Partial<MonitorIntervalOptions>);
    wake(): void;
    stop(): void;
    toString(): string;
    toJSON(): {
        timerId: string;
        lastCallTime: number;
        isExpeditedCheckScheduled: boolean;
        stopped: boolean;
        heartbeatFrequencyMS: number;
        minHeartbeatFrequencyMS: number;
        currentTime: number;
        timeSinceLastCall: number;
    };
    private _reschedule;
    private _executeAndReschedule;
}
export {};
//# sourceMappingURL=monitor.d.ts.map