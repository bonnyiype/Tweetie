/// <reference types="node" />
import type { BSONSerializeOptions, Document, Long } from '../bson';
import { ReadPreference } from '../read_preference';
import type { ClientSession } from '../sessions';
import type { CommandOptions } from './connection';
/** @internal */
export type WriteProtocolMessageType = Query | Msg;
/** @internal */
export interface OpQueryOptions extends CommandOptions {
    socketTimeoutMS?: number;
    session?: ClientSession;
    documentsReturnedIn?: string;
    numberToSkip?: number;
    numberToReturn?: number;
    returnFieldSelector?: Document;
    pre32Limit?: number;
    serializeFunctions?: boolean;
    ignoreUndefined?: boolean;
    maxBsonSize?: number;
    checkKeys?: boolean;
    secondaryOk?: boolean;
    requestId?: number;
    moreToCome?: boolean;
    exhaustAllowed?: boolean;
    readPreference?: ReadPreference;
}
/**************************************************************
 * QUERY
 **************************************************************/
/** @internal */
export declare class Query {
    ns: string;
    query: Document;
    numberToSkip: number;
    numberToReturn: number;
    returnFieldSelector?: Document;
    requestId: number;
    pre32Limit?: number;
    serializeFunctions: boolean;
    ignoreUndefined: boolean;
    maxBsonSize: number;
    checkKeys: boolean;
    batchSize: number;
    tailable: boolean;
    secondaryOk: boolean;
    oplogReplay: boolean;
    noCursorTimeout: boolean;
    awaitData: boolean;
    exhaust: boolean;
    partial: boolean;
    documentsReturnedIn?: string;
    constructor(ns: string, query: Document, options: OpQueryOptions);
    /** Assign next request Id. */
    incRequestId(): void;
    /** Peek next request Id. */
    nextRequestId(): number;
    /** Increment then return next request Id. */
    static getRequestId(): number;
    toBin(): Uint8Array[];
}
/** @internal */
export interface MessageHeader {
    length: number;
    requestId: number;
    responseTo: number;
    opCode: number;
    fromCompressed?: boolean;
}
/** @internal */
export interface OpResponseOptions extends BSONSerializeOptions {
    documentsReturnedIn?: string | null;
}
/** @internal */
export declare class Response {
    parsed: boolean;
    raw: Buffer;
    data: Buffer;
    opts: OpResponseOptions;
    length: number;
    requestId: number;
    responseTo: number;
    opCode: number;
    fromCompressed?: boolean;
    responseFlags?: number;
    cursorId?: Long;
    startingFrom?: number;
    numberReturned?: number;
    documents: (Document | Buffer)[];
    cursorNotFound?: boolean;
    queryFailure?: boolean;
    shardConfigStale?: boolean;
    awaitCapable?: boolean;
    promoteLongs: boolean;
    promoteValues: boolean;
    promoteBuffers: boolean;
    bsonRegExp?: boolean;
    index?: number;
    constructor(message: Buffer, msgHeader: MessageHeader, msgBody: Buffer, opts?: OpResponseOptions);
    isParsed(): boolean;
    parse(options: OpResponseOptions): void;
}
/** @internal */
export interface OpMsgOptions {
    requestId: number;
    serializeFunctions: boolean;
    ignoreUndefined: boolean;
    checkKeys: boolean;
    maxBsonSize: number;
    moreToCome: boolean;
    exhaustAllowed: boolean;
    readPreference: ReadPreference;
}
/** @internal */
export declare class Msg {
    ns: string;
    command: Document;
    options: OpQueryOptions;
    requestId: number;
    serializeFunctions: boolean;
    ignoreUndefined: boolean;
    checkKeys: boolean;
    maxBsonSize: number;
    checksumPresent: boolean;
    moreToCome: boolean;
    exhaustAllowed: boolean;
    constructor(ns: string, command: Document, options: OpQueryOptions);
    toBin(): Buffer[];
    makeDocumentSegment(buffers: Uint8Array[], document: Document): number;
    serializeBson(document: Document): Uint8Array;
    static getRequestId(): number;
}
/** @internal */
export declare class BinMsg {
    parsed: boolean;
    raw: Buffer;
    data: Buffer;
    opts: OpResponseOptions;
    length: number;
    requestId: number;
    responseTo: number;
    opCode: number;
    fromCompressed?: boolean;
    responseFlags: number;
    checksumPresent: boolean;
    moreToCome: boolean;
    exhaustAllowed: boolean;
    promoteLongs: boolean;
    promoteValues: boolean;
    promoteBuffers: boolean;
    bsonRegExp: boolean;
    documents: (Document | Buffer)[];
    index?: number;
    constructor(message: Buffer, msgHeader: MessageHeader, msgBody: Buffer, opts?: OpResponseOptions);
    isParsed(): boolean;
    parse(options: OpResponseOptions): void;
    parseBsonSerializationOptions({ enableUtf8Validation }: BSONSerializeOptions): {
        utf8: {
            writeErrors: false;
        } | false;
    };
}
//# sourceMappingURL=commands.d.ts.map