/// <reference types="node" />
import type { BSONSerializeOptions, Document, ObjectId } from '../bson';
import type { AutoEncrypter } from '../deps';
import type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';
import { CancellationToken, TypedEventEmitter } from '../mongo_types';
import type { ReadPreferenceLike } from '../read_preference';
import { ClientSession } from '../sessions';
import { Callback, ClientMetadata, HostAddress, MongoDBNamespace } from '../utils';
import type { WriteConcern } from '../write_concern';
import type { MongoCredentials } from './auth/mongo_credentials';
import { CommandFailedEvent, CommandStartedEvent, CommandSucceededEvent } from './command_monitoring_events';
import { BinMsg, Response } from './commands';
import type { Stream } from './connect';
import { MessageStream, OperationDescription } from './message_stream';
import { StreamDescription, StreamDescriptionOptions } from './stream_description';
/** @internal */
declare const kStream: unique symbol;
/** @internal */
declare const kQueue: unique symbol;
/** @internal */
declare const kMessageStream: unique symbol;
/** @internal */
declare const kGeneration: unique symbol;
/** @internal */
declare const kLastUseTime: unique symbol;
/** @internal */
declare const kClusterTime: unique symbol;
/** @internal */
declare const kDescription: unique symbol;
/** @internal */
declare const kHello: unique symbol;
/** @internal */
declare const kAutoEncrypter: unique symbol;
/** @internal */
declare const kDelayedTimeoutId: unique symbol;
/** @internal */
export interface CommandOptions extends BSONSerializeOptions {
    command?: boolean;
    secondaryOk?: boolean;
    /** Specify read preference if command supports it */
    readPreference?: ReadPreferenceLike;
    monitoring?: boolean;
    socketTimeoutMS?: number;
    /** Session to use for the operation */
    session?: ClientSession;
    documentsReturnedIn?: string;
    noResponse?: boolean;
    omitReadPreference?: boolean;
    willRetryWrite?: boolean;
    writeConcern?: WriteConcern;
}
/** @public */
export interface ProxyOptions {
    proxyHost?: string;
    proxyPort?: number;
    proxyUsername?: string;
    proxyPassword?: string;
}
/** @public */
export interface ConnectionOptions extends SupportedNodeConnectionOptions, StreamDescriptionOptions, ProxyOptions {
    id: number | '<monitor>';
    generation: number;
    hostAddress: HostAddress;
    autoEncrypter?: AutoEncrypter;
    serverApi?: ServerApi;
    monitorCommands: boolean;
    /** @internal */
    connectionType?: typeof Connection;
    credentials?: MongoCredentials;
    connectTimeoutMS?: number;
    tls: boolean;
    keepAlive?: boolean;
    keepAliveInitialDelay?: number;
    noDelay?: boolean;
    socketTimeoutMS?: number;
    cancellationToken?: CancellationToken;
    metadata: ClientMetadata;
}
/** @internal */
export interface DestroyOptions {
    /** Force the destruction. */
    force?: boolean;
}
/** @public */
export type ConnectionEvents = {
    commandStarted(event: CommandStartedEvent): void;
    commandSucceeded(event: CommandSucceededEvent): void;
    commandFailed(event: CommandFailedEvent): void;
    clusterTimeReceived(clusterTime: Document): void;
    close(): void;
    message(message: any): void;
    pinned(pinType: string): void;
    unpinned(pinType: string): void;
};
/** @internal */
export declare class Connection extends TypedEventEmitter<ConnectionEvents> {
    id: number | '<monitor>';
    address: string;
    socketTimeoutMS: number;
    monitorCommands: boolean;
    closed: boolean;
    destroyed: boolean;
    lastHelloMS?: number;
    serverApi?: ServerApi;
    helloOk?: boolean;
    /**@internal */
    [kDelayedTimeoutId]: NodeJS.Timeout | null;
    /** @internal */
    [kDescription]: StreamDescription;
    /** @internal */
    [kGeneration]: number;
    /** @internal */
    [kLastUseTime]: number;
    /** @internal */
    [kQueue]: Map<number, OperationDescription>;
    /** @internal */
    [kMessageStream]: MessageStream;
    /** @internal */
    [kStream]: Stream;
    /** @internal */
    [kHello]: Document | null;
    /** @internal */
    [kClusterTime]: Document | null;
    /** @event */
    static readonly COMMAND_STARTED: "commandStarted";
    /** @event */
    static readonly COMMAND_SUCCEEDED: "commandSucceeded";
    /** @event */
    static readonly COMMAND_FAILED: "commandFailed";
    /** @event */
    static readonly CLUSTER_TIME_RECEIVED: "clusterTimeReceived";
    /** @event */
    static readonly CLOSE: "close";
    /** @event */
    static readonly MESSAGE: "message";
    /** @event */
    static readonly PINNED: "pinned";
    /** @event */
    static readonly UNPINNED: "unpinned";
    constructor(stream: Stream, options: ConnectionOptions);
    get description(): StreamDescription;
    get hello(): Document | null;
    set hello(response: Document | null);
    set isMonitoringConnection(value: boolean);
    get isMonitoringConnection(): boolean;
    get serviceId(): ObjectId | undefined;
    get loadBalanced(): boolean;
    get generation(): number;
    set generation(generation: number);
    get idleTime(): number;
    get clusterTime(): Document | null;
    get stream(): Stream;
    markAvailable(): void;
    onError(error: Error): void;
    onClose(): void;
    onTimeout(): void;
    onMessage(message: BinMsg | Response): void;
    destroy(options?: DestroyOptions, callback?: Callback): void;
    command(ns: MongoDBNamespace, cmd: Document, options: CommandOptions | undefined, callback: Callback): void;
}
/** @internal */
export declare class CryptoConnection extends Connection {
    /** @internal */
    [kAutoEncrypter]?: AutoEncrypter;
    constructor(stream: Stream, options: ConnectionOptions);
    /** @internal @override */
    command(ns: MongoDBNamespace, cmd: Document, options: CommandOptions, callback: Callback): void;
}
/** @internal */
export declare function hasSessionSupport(conn: Connection): boolean;
export {};
//# sourceMappingURL=connection.d.ts.map